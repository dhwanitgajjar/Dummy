import streamlit as st
import os
import sys
import pandas as pd
from bs4 import BeautifulSoup
import requests
import time
import io

# Configuration for FastAPI backend
FASTAPI_BASE_URL = "http://localhost:8000"  # Adjust this to your FastAPI server URL

# Adjust the path to import from the 'base' directory correctly (if needed for constants)
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

# Import only constants if needed for display purposes
try:
    from base.constants import (INPUT_DIR, OUTPUT_DIR, GPT_MODEL, MULTIPLIER, SKIP_MAX_ATTEMPTS, CLAUSES_PRESENT)
except ImportError:
    # Fallback values if constants not available
    INPUT_DIR = "input"
    OUTPUT_DIR = "output"
    GPT_MODEL = "gpt-4"
    MULTIPLIER = 1
    SKIP_MAX_ATTEMPTS = False
    CLAUSES_PRESENT = True

# Ensure directories exist (for local file handling if needed)
os.makedirs(INPUT_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Function to save uploaded file (kept for compatibility)
def save_uploaded_file(uploaded_file, directory):
    """Saves an uploaded file to a specified directory."""
    if uploaded_file is not None:
        file_path = os.path.join(directory, uploaded_file.name)
        with open(file_path, "wb") as f:
            f.write(uploaded_file.getbuffer())
        return file_path
    return None

def upload_files_to_fastapi(policy_file, nda_file):
    """Upload files to FastAPI backend and start processing"""
    try:
        # Prepare files for upload
        files = {
            'policy_file': (policy_file.name, policy_file.getvalue(), policy_file.type),
            'nda_file': (nda_file.name, nda_file.getvalue(), nda_file.type)
        }

        # Make API call to start processing
        response = requests.post(f"{FASTAPI_BASE_URL}/process", files=files)

        if response.status_code == 200:
            return response.json()
        else:
            st.error(f"Upload failed: {response.status_code} - {response.text}")
            return None

    except requests.exceptions.ConnectionError:
        st.error("Cannot connect to FastAPI server. Make sure it's running on port 8000.")
        return None
    except Exception as e:
        st.error(f"Error uploading files: {str(e)}")
        return None

def monitor_processing_status(task_id):
    """Monitor processing status and return results when complete"""
    progress_bar = st.progress(0)
    status_text = st.empty()

    max_attempts = 120  # 10 minutes with 5-second intervals
    attempt = 0

    while attempt < max_attempts:
        try:
            response = requests.get(f"{FASTAPI_BASE_URL}/status/{task_id}")

            if response.status_code == 200:
                status_data = response.json()
                status = status_data.get('status', 'unknown')
                progress = status_data.get('progress', 0)

                # Update progress bar and status
                progress_bar.progress(progress / 100.0)
                status_text.text(f"Status: {status} | Progress: {progress}%")

                if status == 'completed':
                    progress_bar.progress(1.0)
                    status_text.success("Processing completed successfully!")
                    return status_data

                elif status == 'error':
                    error_msg = status_data.get('error', 'Unknown error')
                    status_text.error(f"Processing failed: {error_msg}")
                    return None

                else:
                    # Still processing, wait and check again
                    time.sleep(5)
                    attempt += 1

            else:
                status_text.error(f"Status check failed: {response.status_code}")
                return None

        except Exception as e:
            status_text.error(f"Error checking status: {str(e)}")
            return None

    status_text.error("Processing timeout - took too long (10+ minutes)")
    return None

def download_file_from_fastapi(filename):
    """Download a file from FastAPI backend"""
    try:
        response = requests.get(f"{FASTAPI_BASE_URL}/download/{filename}")
        if response.status_code == 200:
            return response.content
        else:
            st.error(f"Download failed for {filename}: {response.status_code}")
            return None
    except Exception as e:
        st.error(f"Error downloading {filename}: {str(e)}")
        return None

def run_processing_workflow(policy_file_path, nda_file_path, multiplier, llm_helper):
    """
    This method is kept for compatibility but now delegates to FastAPI
    In the new architecture, this logic runs on the FastAPI backend
    """
    st.info("This method now runs on the FastAPI backend")
    return None, None

def generate_and_save_outputs(rewritten_nda_sections_text, nda_filename):
    """
    This method is kept for compatibility but now handled by FastAPI backend
    In the new architecture, this logic runs on the FastAPI backend
    """
    st.info("This method now runs on the FastAPI backend")
    return None, None, None

# --- Streamlit UI ---
st.set_page_config(page_title="Document Processing App", layout="wide")
st.markdown(
    """
    <style>
    .stApp {
        background-color: grey;
    }
    </style>
    """,
    unsafe_allow_html=True
)
st.title("NDA Processing with LLM")
st.markdown("Upload your Policy and NDA documents to generate a revised NDA.")

# Display FastAPI connection status
try:
    response = requests.get(f"{FASTAPI_BASE_URL}/", timeout=5)
    if response.status_code == 200:
        st.success("✅ Connected to FastAPI backend")
    else:
        st.warning(f"⚠️ FastAPI backend responded with status: {response.status_code}")
except:
    st.error("❌ Cannot connect to FastAPI backend. Make sure it's running on port 8000.")
    st.info("Run: `uvicorn endpoint:app --reload` to start the FastAPI server")

# File uploaders
col1, col2 = st.columns(2)
with col1:
    uploaded_policy = st.file_uploader("Upload Policy Document", type=["doc", "docx", "pdf"])
with col2:
    uploaded_nda = st.file_uploader("Upload NDA Document", type=["doc", "docx", "pdf"])

# Processing button
if st.button("Process Documents"):
    if uploaded_policy and uploaded_nda:
        st.info("Saving files and starting the processing...")

        # Upload files to FastAPI and start processing
        result = upload_files_to_fastapi(uploaded_policy, uploaded_nda)

        if result:
            task_id = result.get('task_id')
            st.success(f"Processing started! Task ID: {task_id}")

            # Monitor processing status
            with st.spinner("Processing... This may take a few minutes."):
                status_data = monitor_processing_status(task_id)

                if status_data:
                    st.success("Processing complete!")

                    # Display results
                    files = status_data.get('files', {})
                    preview_content = status_data.get('preview_content', '')
                    preprocessed_filename = status_data.get('preprocessed_filename', 'processed')

                    # Display and Download Buttons
                    st.subheader("Results")
                    excel_report_path = files.get('excel_report', '')
                    st.markdown(f"**Reports saved to:** `{os.path.basename(excel_report_path) if excel_report_path else 'Unknown'}`")

                    # Show the HTML result directly in the app
                    st.subheader("Rewritten NDA (HTML)")
                    if preview_content:
                        st.markdown(preview_content, unsafe_allow_html=True)
                    else:
                        st.warning("No preview content available")

                    # Download buttons
                    st.subheader("Download Files")

                    # Create download buttons for each file
                    download_col1, download_col2 = st.columns(2)

                    with download_col1:
                        # Download Rewritten HTML
                        if files.get('html_with_revisions'):
                            html_filename = os.path.basename(files['html_with_revisions'])
                            html_content = download_file_from_fastapi(html_filename)
                            if html_content:
                                st.download_button(
                                    label="Download Rewritten HTML",
                                    data=html_content,
                                    file_name=html_filename,
                                    mime="text/html"
                                )

                    with download_col2:
                        # Download Rewritten DOCX
                        if files.get('docx_file'):
                            docx_filename = os.path.basename(files['docx_file'])
                            docx_content = download_file_from_fastapi(docx_filename)
                            if docx_content:
                                st.download_button(
                                    label="Download Rewritten DOCX",
                                    data=docx_content,
                                    file_name=docx_filename,
                                    mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                                )

                    # Additional download options
                    st.subheader("Additional Downloads")
                    download_col3, download_col4 = st.columns(2)

                    with download_col3:
                        # Download Excel Report
                        if files.get('excel_report'):
                            excel_filename = os.path.basename(files['excel_report'])
                            excel_content = download_file_from_fastapi(excel_filename)
                            if excel_content:
                                st.download_button(
                                    label="Download Excel Report",
                                    data=excel_content,
                                    file_name=excel_filename,
                                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                                )

                    with download_col4:
                        # Download HTML without rationale
                        if files.get('html_no_rationale'):
                            html_no_rat_filename = os.path.basename(files['html_no_rationale'])
                            html_no_rat_content = download_file_from_fastapi(html_no_rat_filename)
                            if html_no_rat_content:
                                st.download_button(
                                    label="Download HTML (No Rationale)",
                                    data=html_no_rat_content,
                                    file_name=html_no_rat_filename,
                                    mime="text/html"
                                )
                else:
                    st.error("Processing failed or timed out")
    else:
        st.warning("Please upload both a policy and an NDA document to proceed.")

# Add some useful information for users
with st.expander("ℹ️ How it works"):
    st.markdown("""
    **This application now uses a FastAPI backend for processing:**

    1. **File Upload**: Your documents are uploaded to the FastAPI server
    2. **Background Processing**: The server processes your documents in the background
    3. **Real-time Updates**: You'll see progress updates as processing continues
    4. **Results**: Once complete, you can preview and download the generated files

    **Technical Details:**
    - FastAPI Server: `{FASTAPI_BASE_URL}`
    - Processing runs asynchronously on the backend
    - Files are temporarily stored on the server during processing
    - All generated files are available for download
    """.format(FASTAPI_BASE_URL=FASTAPI_BASE_URL))

with st.expander("🔧 Configuration"):
    st.markdown(f"""
    **Current Configuration:**
    - FastAPI URL: `{FASTAPI_BASE_URL}`
    - GPT Model: `{GPT_MODEL}`
    - Multiplier: `{MULTIPLIER}`
    - Skip Max Attempts: `{SKIP_MAX_ATTEMPTS}`
    - Clauses Present: `{CLAUSES_PRESENT}`

    **Directories:**
    - Input Directory: `{INPUT_DIR}`
    - Output Directory: `{OUTPUT_DIR}`
    """)
