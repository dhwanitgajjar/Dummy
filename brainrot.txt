# Modified ui.py - Add checkbox functionality to existing functions
import streamlit as st
import os
import sys
import requests
import time

# Configuration for FastAPI backend
FASTAPI_BASE_URL = "http://localhost:8000" # Adjust this to your FastAPI server URL

# Adjust the path to import from the 'base' directory correctly (if needed for constants)
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

# Import only constants if needed for display purposes
try:
    from base.constants import (INPUT_DIR, OUTPUT_DIR)
except ImportError:
    # Fallback values if constants not available
    INPUT_DIR = "input"
    OUTPUT_DIR = "output"

# Ensure directories exist (for local file handling if needed)
os.makedirs(INPUT_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Add session state initialization at the top of the file
if 'ai_suggestions' not in st.session_state:
    st.session_state.ai_suggestions = []
if 'selected_suggestions' not in st.session_state:
    st.session_state.selected_suggestions = {}
if 'current_task_id' not in st.session_state:
    st.session_state.current_task_id = None

# Function to save uploaded file (kept for compatibility)
def save_uploaded_file(uploaded_file, directory):
    """Saves an uploaded file to a specified directory."""
    if uploaded_file is not None:
        file_path = os.path.join(directory, uploaded_file.name)
        with open(file_path, "wb") as f:
            f.write(uploaded_file.getbuffer())
        return file_path
    return None

def upload_files_to_fastapi(policy_file, nda_file):
    """Upload files to FastAPI backend and start processing"""
    try:
        # Prepare files for upload
        files = {
            'policy_file': (policy_file.name, policy_file.getvalue(), policy_file.type),
            'nda_file': (nda_file.name, nda_file.getvalue(), nda_file.type)
        }
        
        # Make API call to start processing
        response = requests.post(f"{FASTAPI_BASE_URL}/process", files=files)
        if response.status_code == 200:
            return response.json()
        else:
            st.error(f"Upload failed: {response.status_code} - {response.text}")
            return None
    except requests.exceptions.ConnectionError:
        st.error("Cannot connect to FastAPI server. Make sure it's running on port 8000.")
        return None
    except Exception as e:
        st.error(f"Error uploading files: {str(e)}")
        return None

def monitor_processing_status(task_id):
    """Monitor processing status and return results when complete - MODIFIED to handle suggestions"""
    progress_bar = st.progress(0)
    status_text = st.empty()
    max_attempts = 120 # 10 minutes with 5-second intervals
    attempt = 0

    while attempt < max_attempts:
        try:
            response = requests.get(f"{FASTAPI_BASE_URL}/status/{task_id}")
            if response.status_code == 200:
                status_data = response.json()
                status = status_data.get('status', 'unknown')
                progress = status_data.get('progress', 0)

                # Update progress bar and status
                progress_bar.progress(progress / 100.0)
                status_text.text(f"Status: {status} | Progress: {progress}%")

                if status == 'completed':
                    progress_bar.progress(1.0)
                    status_text.success("Processing completed successfully!")
                    
                    # MODIFIED: Extract and store suggestions if available
                    suggestions = status_data.get('suggestions', [])
                    if suggestions:
                        st.session_state.ai_suggestions = suggestions
                        st.session_state.current_task_id = task_id
                        # Initialize all suggestions as selected by default
                        st.session_state.selected_suggestions = {
                            suggestion['id']: True for suggestion in suggestions
                        }
                    
                    return status_data
                elif status == 'error':
                    error_msg = status_data.get('error', 'Unknown error')
                    status_text.error(f"Processing failed: {error_msg}")
                    return None
                else:
                    # Still processing, wait and check again
                    time.sleep(5)
                    attempt += 1
            else:
                status_text.error(f"Status check failed: {response.status_code}")
                return None
        except Exception as e:
            status_text.error(f"Error checking status: {str(e)}")
            return None

    status_text.error("Processing timeout - took too long (10+ minutes)")
    return None

def download_file_from_fastapi(filename):
    """Download a file from FastAPI backend"""
    try:
        response = requests.get(f"{FASTAPI_BASE_URL}/download/{filename}")
        if response.status_code == 200:
            return response.content
        else:
            st.error(f"Download failed for {filename}: {response.status_code}")
            return None
    except Exception as e:
        st.error(f"Error downloading {filename}: {str(e)}")
        return None

def run_processing_workflow(policy_file_path, nda_file_path, multiplier, llm_helper):
    """
    This method is kept for compatibility but now delegates to FastAPI backend
    In the new architecture, this logic runs on the FastAPI backend
    """
    st.info("This method now runs on the FastAPI backend")
    return None, None

def generate_and_save_outputs(rewritten_nda_sections_text, nda_filename):
    """
    This method is kept for compatibility but now handled by FastAPI backend
    In the new architecture, this logic runs on the FastAPI backend
    MODIFIED: Now also handles selective generation based on checkbox selections
    """
    # If we have selections, process them selectively
    if st.session_state.selected_suggestions and st.session_state.current_task_id:
        selected_ids = [
            suggestion_id for suggestion_id, is_selected 
            in st.session_state.selected_suggestions.items() 
            if is_selected
        ]
        
        if selected_ids:
            try:
                # Send selected suggestions to backend for processing
                selection_data = {
                    'task_id': st.session_state.current_task_id,
                    'selected_suggestion_ids': selected_ids
                }
                
                response = requests.post(f"{FASTAPI_BASE_URL}/process_selections", json=selection_data)
                if response.status_code == 200:
                    result = response.json()
                    return result.get('files', {}), None, None
                else:
                    st.error(f"Selection processing failed: {response.status_code}")
                    return None, None, None
            except Exception as e:
                st.error(f"Error processing selections: {str(e)}")
                return None, None, None
    
    st.info("This method now runs on the FastAPI backend")
    return None, None, None

# NEW HELPER FUNCTION: Display suggestions with checkboxes (added to existing structure)
def display_suggestions_interface():
    """Display AI suggestions with checkbox selection interface"""
    if not st.session_state.ai_suggestions:
        return False
    
    st.markdown("---")
    st.subheader("ü§ñ AI Suggestions - Review and Select")
    st.markdown("Review each suggestion and choose which ones to include in your final document.")
    
    # Control buttons
    col1, col2, col3 = st.columns([1, 1, 2])
    with col1:
        if st.button("‚úÖ Select All", key="select_all_suggestions"):
            for suggestion in st.session_state.ai_suggestions:
                st.session_state.selected_suggestions[suggestion['id']] = True
            st.experimental_rerun()
    
    with col2:
        if st.button("‚ùå Deselect All", key="deselect_all_suggestions"):
            for suggestion in st.session_state.ai_suggestions:
                st.session_state.selected_suggestions[suggestion['id']] = False
            st.experimental_rerun()
    
    with col3:
        selected_count = sum(1 for selected in st.session_state.selected_suggestions.values() if selected)
        total_count = len(st.session_state.ai_suggestions)
        st.info(f"üìä Selected: {selected_count} / {total_count} suggestions")
    
    st.markdown("---")
    
    # Display each suggestion
    for suggestion in st.session_state.ai_suggestions:
        suggestion_id = suggestion['id']
        
        with st.expander(f"üìù {suggestion.get('section', f'Suggestion {suggestion_id}')}", expanded=False):
            # Checkbox for this suggestion
            current_selection = st.session_state.selected_suggestions.get(suggestion_id, True)
            is_selected = st.checkbox(
                "Include this suggestion in final document",
                value=current_selection,
                key=f"suggestion_checkbox_{suggestion_id}"
            )
            
            # Update session state
            st.session_state.selected_suggestions[suggestion_id] = is_selected
            
            # Display suggestion details in columns
            col1, col2 = st.columns([1, 1])
            
            with col1:
                st.markdown("**üìÑ Original Text:**")
                st.text_area(
                    "Original",
                    value=suggestion.get('original_text', 'N/A'),
                    height=120,
                    disabled=True,
                    key=f"original_text_{suggestion_id}",
                    label_visibility="collapsed"
                )
            
            with col2:
                st.markdown("**‚ú® Suggested Text:**")
                st.text_area(
                    "Suggested",
                    value=suggestion.get('suggested_text', 'N/A'),
                    height=120,
                    disabled=True,
                    key=f"suggested_text_{suggestion_id}",
                    label_visibility="collapsed"
                )
            
            # Rationale
            st.markdown("**üí° Rationale:**")
            st.write(suggestion.get('rationale', 'No rationale provided'))
            
            # Confidence score if available
            if 'confidence' in suggestion:
                confidence = float(suggestion['confidence'])
                st.progress(confidence, text=f"AI Confidence: {confidence:.1%}")
            
            # Selection status indicator
            if is_selected:
                st.success("‚úÖ This suggestion will be included in the final document")
            else:
                st.warning("‚ùå This suggestion will be excluded from the final document")
    
    return True

# --- Streamlit UI ---
st.set_page_config(page_title="Enhanced NDA Processing App", layout="wide")

custom_css = """
<style>
.suggestion-selected {
    background-color: #e8f5e8;
    border-left: 4px solid #2ca02c;
    padding: 10px;
    border-radius: 5px;
    margin: 5px 0;
}
.suggestion-deselected {
    background-color: #fdf2f2;
    border-left: 4px solid #d62728;
    padding: 10px;
    border-radius: 5px;
    margin: 5px 0;
}
</style>
"""

# Inject the custom CSS into the Streamlit app
st.markdown(custom_css, unsafe_allow_html=True)

st.title("Enhanced NDA Processing with AI Suggestion Selection")
st.markdown("Upload your Policy and NDA documents to generate AI suggestions, then choose which ones to keep.")

# Display FastAPI connection status
try:
    response = requests.get(f"{FASTAPI_BASE_URL}/", timeout=5)
    if response.status_code == 200:
        st.success("‚úÖ Connected to FastAPI backend")
    else:
        st.warning(f"‚ö†Ô∏è FastAPI backend responded with status: {response.status_code}")
except:
    st.error("‚ùå Cannot connect to FastAPI backend. Make sure it's running on port 8000.")
    st.info("Run: `uvicorn endpoint:app --reload` to start the FastAPI server")

# File uploaders
col1, col2 = st.columns(2)

with col1:
    uploaded_policy = st.file_uploader("Upload Policy Document", type=["doc", "docx", "pdf"])

with col2:
    uploaded_nda = st.file_uploader("Upload NDA Document", type=["doc", "docx", "pdf"])

# Processing button
if st.button("üöÄ Process Documents and Get AI Suggestions", type="primary"):
    if uploaded_policy and uploaded_nda:
        st.info("Saving files and starting the processing...")
        
        # Reset suggestions from previous runs
        st.session_state.ai_suggestions = []
        st.session_state.selected_suggestions = {}
        st.session_state.current_task_id = None
        
        # Upload files to FastAPI and start processing
        result = upload_files_to_fastapi(uploaded_policy, uploaded_nda)
        
        if result:
            task_id = result.get('task_id')
            st.success(f"Processing started! Task ID: {task_id}")
            
            # Monitor processing status
            with st.spinner("Processing... This may take a few minutes."):
                status_data = monitor_processing_status(task_id)
            
            if status_data:
                st.success("‚úÖ Processing complete! AI suggestions are ready for review.")
                st.experimental_rerun()  # Refresh to show suggestions
    else:
        st.warning("Please upload both a policy and an NDA document to proceed.")

# MODIFIED: Display suggestions interface if suggestions are available
if display_suggestions_interface():
    # Generate final document button
    st.markdown("---")
    
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        if st.button("üìÑ Generate Final Document with Selected Suggestions", type="primary", key="generate_final"):
            selected_count = sum(1 for selected in st.session_state.selected_suggestions.values() if selected)
            
            if selected_count > 0:
                st.info(f"Generating final document with {selected_count} selected suggestions...")
                
                # Use the modified generate_and_save_outputs function
                files, _, _ = generate_and_save_outputs(None, None)
                
                if files:
                    st.success("üéâ Final document generated successfully!")
                    
                    # Display download options
                    st.subheader("üì• Download Your Customized Documents")
                    
                    download_col1, download_col2, download_col3 = st.columns(3)
                    
                    with download_col1:
                        if files.get('html_with_revisions'):
                            html_filename = os.path.basename(files['html_with_revisions'])
                            html_content = download_file_from_fastapi(html_filename)
                            if html_content:
                                st.download_button(
                                    label="üìÑ Download HTML",
                                    data=html_content,
                                    file_name=html_filename,
                                    mime="text/html"
                                )
                    
                    with download_col2:
                        if files.get('docx_file'):
                            docx_filename = os.path.basename(files['docx_file'])
                            docx_content = download_file_from_fastapi(docx_filename)
                            if docx_content:
                                st.download_button(
                                    label="üìù Download DOCX",
                                    data=docx_content,
                                    file_name=docx_filename,
                                    mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                                )
                    
                    with download_col3:
                        if files.get('excel_report'):
                            excel_filename = os.path.basename(files['excel_report'])
                            excel_content = download_file_from_fastapi(excel_filename)
                            if excel_content:
                                st.download_button(
                                    label="üìä Download Report",
                                    data=excel_content,
                                    file_name=excel_filename,
                                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                                )
            else:
                st.warning("‚ö†Ô∏è Please select at least one suggestion to generate the final document.")

# ORIGINAL: Display regular results if no suggestions are available but processing is complete
elif st.session_state.get('show_regular_results', False):
    # Your existing results display code here...
    pass

# Add some useful information for users
with st.expander("‚ÑπÔ∏è How the Enhanced Selection Process Works"):
    st.markdown("""
    **This enhanced application now includes AI suggestion selection:**
    
    1. **üì§ File Upload**: Upload your Policy and NDA documents
    2. **ü§ñ AI Processing**: The system analyzes and generates improvement suggestions
    3. **‚úÖ Review & Select**: Use checkboxes to choose which suggestions to keep
    4. **üìÑ Generate Document**: Create final document with only your selected improvements
    5. **üì• Download**: Get your customized files
    
    **Selection Features:**
    - ‚úÖ Individual checkbox selection for each suggestion
    - üîÑ Select All / Deselect All for quick decisions
    - üìä Real-time counter showing selected suggestions
    - üí° Detailed rationale for each AI suggestion
    - üìà Confidence scores when available
    
    **Technical Details:**
    - FastAPI Server: `{FASTAPI_BASE_URL}`
    - Your selections are preserved during the session
    - Only selected suggestions are applied to the final document
    """.format(FASTAPI_BASE_URL=FASTAPI_BASE_URL))
