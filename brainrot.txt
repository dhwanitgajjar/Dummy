import streamlit as st
import os
import sys
import pandas as pd
from bs4 import BeautifulSoup
import requests
import time

# Adjust the path to import from the 'base' directory correctly
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

# Import all necessary functions from your main.py and other modules
from base.constants import (INPUT_DIR, OUTPUT_DIR, GPT_MODEL, MULTIPLIER, SKIP_MAX_ATTEMPTS, CLAUSES_PRESENT)
from base.llm_helper import LLMHelper
from base.file_processing import convert_and_extract_text, analyze_document_fonts
from base.break_documents_into_parts import break_the_document_into_parts, get_nda_sections_list
from base.get_nda_analysis import get_nda_review_and_amendments
from base.processing_amendments import process_amendments
from base.deduplication_of_amendments import deduplication_of_amendments, deduplicate_amendments_reports, update_sections_list
from base.save_to_excel import save_to_excel_with_multiple_sheets
from base.utils import preprocess_filename, html_to_clean_docx
from base.rewrite_nda_section import process_nda_sections

# Ensure INPUT_DIR and OUTPUT_DIR exist
os.makedirs(INPUT_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Configuration for your existing FastAPI
FASTAPI_BASE_URL = "http://localhost:8000"  # Your existing FastAPI URL

# Initialize session state for suggestion workflow
if 'processing_stage' not in st.session_state:
    st.session_state.processing_stage = 'upload'
if 'suggestions_data' not in st.session_state:
    st.session_state.suggestions_data = None
if 'accepted_suggestions' not in st.session_state:
    st.session_state.accepted_suggestions = {}

# Function to save uploaded file (UNCHANGED from your original)
def save_uploaded_file(uploaded_file, directory):
    """Saves an uploaded file to a specified directory."""
    if uploaded_file is not None:
        file_path = os.path.join(directory, uploaded_file.name)
        with open(file_path, "wb") as f:
            f.write(uploaded_file.getbuffer())
        return file_path
    return None

# Your original processing function (UNCHANGED)
def run_processing_workflow(policy_file_path, nda_file_path, multiplier, llm_helper):
    """
    Encapsulates the core processing logic from your main.py.
    This function takes file paths and other dependencies as arguments.
    """
    # Extract the policy text
    policy_returned_filename, policy_text = convert_and_extract_text(INPUT_DIR, os.path.basename(policy_file_path))

    # Extract the NDA text
    nda_returned_filename, nda_text = convert_and_extract_text(INPUT_DIR, os.path.basename(nda_file_path))

    # Break the document into parts
    structured_parts = break_the_document_into_parts(nda_text, nda_returned_filename)
    nda_sections_list = get_nda_sections_list(structured_parts)

    # Generate amendments report
    list_of_amendments = get_nda_review_and_amendments(policy_text, nda_text, nda_sections_list, llm_helper)
    amendments_report = process_amendments(list_of_amendments)
    dedup_analysis, id_to_amendment = deduplication_of_amendments(amendments_report, llm_helper)
    dedup_amendments_report = deduplicate_amendments_reports(dedup_analysis, id_to_amendment)
    updated_list = update_sections_list(nda_sections_list, dedup_amendments_report)

    # Save reports to excel
    preprocessed_filename = preprocess_filename(os.path.basename(nda_file_path))
    reports_filename = os.path.join(OUTPUT_DIR, f"{preprocessed_filename}_amendments_report.xlsx")
    data_dict = {
        "Amendments Report": pd.DataFrame(amendments_report),
        "DeDuplication Analysis": pd.DataFrame(dedup_analysis),
        "Dedup Amendments Report": pd.DataFrame(dedup_amendments_report),
        "NDA Sections": pd.DataFrame(nda_sections_list),
    }
    save_to_excel_with_multiple_sheets(data_dict, reports_filename)

    # Return data for suggestion review instead of final processing
    return {
        'dedup_amendments_report': dedup_amendments_report,
        'updated_list': updated_list,
        'nda_sections_list': nda_sections_list,
        'reports_filename': reports_filename,
        'preprocessed_filename': preprocessed_filename
    }

# NEW: Function to generate final output with only accepted suggestions
def run_final_processing_with_accepted_suggestions(suggestions_data, accepted_suggestions, uploaded_nda_name):
    """Generate final output using only accepted suggestions"""
    try:
        # Filter amendments to only include accepted ones
        filtered_amendments = []
        for i, amendment in enumerate(suggestions_data['dedup_amendments_report']):
            if accepted_suggestions.get(f"suggestion_{i}", False):
                filtered_amendments.append(amendment)

        # If no suggestions were accepted, use original content
        if not filtered_amendments:
            st.warning("No suggestions were accepted. Using original content.")
            original_sections = [str(section) for section in suggestions_data['nda_sections_list']]
            return " ".join(original_sections)

        # Initialize LLM helper for final processing
        llm_helper = LLMHelper(GPT_MODEL)
        multiplier = MULTIPLIER

        # Process only accepted amendments
        result = process_nda_sections(suggestions_data['updated_list'], suggestions_data['nda_sections_list'], filtered_amendments, llm_helper, multiplier)
        rewritten_nda_sections_text = " ".join(result)

        return rewritten_nda_sections_text

    except Exception as e:
        st.error(f"Error in final processing: {str(e)}")
        return None

# Your original output generation function (UNCHANGED)
def generate_and_save_outputs(rewritten_nda_sections_text, nda_filename):
    """Generates and saves the HTML and DOCX outputs."""
    preprocessed_filename = preprocess_filename(nda_filename)

    # Generate HTML version
    rewritten_nda_html_filename = os.path.join(OUTPUT_DIR, preprocessed_filename + f"_rewritten_nda_{'v1' if SKIP_MAX_ATTEMPTS else 'v2'}.html")
    with open(rewritten_nda_html_filename, "w", encoding="utf-8") as f:
        f.write(rewritten_nda_sections_text)

    # Generate HTML version without rationale
    soup = BeautifulSoup(rewritten_nda_sections_text, 'html.parser')
    for tag in soup.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):
        if tag.text.strip() in ['HEADER', 'FOOTER']:
            tag.decompose()
    if not CLAUSES_PRESENT:
        for tag in soup.find_all('h2'):
            tag.decompose()
    for span in soup.find_all('span', style=True):
        if 'background-color:yellow' in span['style'].replace(' ', '').lower():
            span.decompose()
    for p in soup.find_all('p', style=True):
        if 'background-color:yellow' in p['style'].replace(' ', '').lower():
            p.decompose()

    rewritten_nda_html_no_rationale_filename = os.path.join(OUTPUT_DIR, preprocessed_filename + f"_rewritten_nda_with_no_rationale_{'v1' if SKIP_MAX_ATTEMPTS else 'v2'}.html")
    with open(rewritten_nda_html_no_rationale_filename, 'w', encoding='utf-8') as f:
        f.write(str(soup))

    # Generate DOCX version
    FONT_NAME = analyze_document_fonts(INPUT_DIR, nda_filename)
    rewritten_nda_docx_filename = os.path.join(OUTPUT_DIR, preprocessed_filename + f"_cleaned_rewritten_nda_{'v1' if SKIP_MAX_ATTEMPTS else 'v2'}.docx")
    html_to_clean_docx(str(soup), rewritten_nda_docx_filename, FONT_NAME)

    return rewritten_nda_html_filename, rewritten_nda_docx_filename, rewritten_nda_html_no_rationale_filename

# NEW: Display suggestions with checkboxes
def display_suggestion_review(suggestions_data):
    """Display suggestions with checkboxes for user to accept/reject"""
    st.header("üìã Review and Accept Suggestions")
    st.markdown("Review the suggestions below and check the ones you want to accept. Only accepted suggestions will be applied to the final document.")

    dedup_amendments_report = suggestions_data['dedup_amendments_report']

    if not dedup_amendments_report:
        st.warning("No suggestions were generated for this document.")
        return False

    # Add select all/none buttons
    col1, col2, col3 = st.columns([1, 1, 4])
    with col1:
        if st.button("‚úÖ Accept All"):
            for i in range(len(dedup_amendments_report)):
                st.session_state.accepted_suggestions[f"suggestion_{i}"] = True
            st.rerun()
    with col2:
        if st.button("‚ùå Reject All"):
            for i in range(len(dedup_amendments_report)):
                st.session_state.accepted_suggestions[f"suggestion_{i}"] = False
            st.rerun()

    st.markdown("---")

    # Display each suggestion with checkbox
    for i, amendment in enumerate(dedup_amendments_report):
        suggestion_key = f"suggestion_{i}"

        with st.container():
            col_check, col_content = st.columns([0.1, 0.9])

            with col_check:
                accepted = st.checkbox(
                    "Accept", 
                    key=suggestion_key,
                    value=st.session_state.accepted_suggestions.get(suggestion_key, True)
                )
                st.session_state.accepted_suggestions[suggestion_key] = accepted

            with col_content:
                # Get suggestion details
                suggestion_title = str(amendment.get('title', amendment.get('suggestion', f'Suggestion {i+1}')))
                suggestion_content = str(amendment.get('suggestion', amendment.get('content', 'No content available')))
                suggestion_rationale = str(amendment.get('rationale', 'No rationale provided'))
                section = str(amendment.get('section', 'Unknown section'))

                # Color code based on acceptance
                if accepted:
                    st.success(f"**‚úÖ {suggestion_title}** (Section: {section})")
                else:
                    st.error(f"**‚ùå {suggestion_title}** (Section: {section})")

                # Show suggestion details in an expander
                with st.expander(f"View details for {suggestion_title}"):
                    st.markdown(f"**Suggestion:** {suggestion_content}")
                    st.markdown(f"**Rationale:** {suggestion_rationale}")
                    if 'original_text' in amendment:
                        st.markdown(f"**Original Text:** {amendment['original_text']}")
                    if 'proposed_text' in amendment:
                        st.markdown(f"**Proposed Text:** {amendment['proposed_text']}")

        st.markdown("---")

    # Summary
    accepted_count = sum(1 for v in st.session_state.accepted_suggestions.values() if v)
    total_count = len(dedup_amendments_report)

    col1, col2 = st.columns(2)
    with col1:
        st.metric("Accepted Suggestions", accepted_count)
    with col2:
        st.metric("Total Suggestions", total_count)

    return True

# --- Streamlit UI (Same styling as your original) ---
st.set_page_config(page_title="Document Processing App", layout="wide")
st.markdown(
    """
    <style>
    .stApp {
        background-color: grey;
    }
    </style>
    """,
    unsafe_allow_html=True
)
st.title("NDA Processing with LLM")
st.markdown("Upload your Policy and NDA documents to generate a revised NDA.")

# Check if using local processing or FastAPI
use_fastapi = st.sidebar.checkbox("Use FastAPI Backend", value=False, help="Enable to use FastAPI backend instead of local processing")

if use_fastapi:
    st.sidebar.info("Using FastAPI backend - make sure your FastAPI server is running")
else:
    st.sidebar.info("Using local processing - all processing happens in Streamlit")

# Stage 1: Upload Documents
if st.session_state.processing_stage == 'upload':
    # File uploaders (same as your original)
    col1, col2 = st.columns(2)
    with col1:
        uploaded_policy = st.file_uploader("Upload Policy Document", type=["doc", "docx", "pdf"])
    with col2:
        uploaded_nda = st.file_uploader("Upload NDA Document", type=["doc", "docx", "pdf"])

    # Process button
    if st.button("Process Documents"):
        if uploaded_policy and uploaded_nda:
            st.info("Saving files and starting the processing...")

            # Save files locally (same as your original)
            policy_path = save_uploaded_file(uploaded_policy, INPUT_DIR)
            nda_path = save_uploaded_file(uploaded_nda, INPUT_DIR)

            if policy_path and nda_path:
                with st.spinner("Processing... This may take a few minutes."):
                    try:
                        # Use your EXACT original processing workflow
                        llm_helper = LLMHelper(GPT_MODEL)
                        multiplier = MULTIPLIER

                        # Run processing to get suggestions (using your exact methods)
                        suggestions_data = run_processing_workflow(policy_path, nda_path, multiplier, llm_helper)

                        # Store data and move to review stage
                        st.session_state.suggestions_data = suggestions_data
                        st.session_state.uploaded_nda_name = uploaded_nda.name
                        st.session_state.processing_stage = 'review'

                        st.success("Processing complete! Now you can review and select suggestions.")
                        st.rerun()

                    except Exception as e:
                        st.error(f"An error occurred during processing: {e}")
        else:
            st.warning("Please upload both a policy and an NDA document to proceed.")

# Stage 2: Review Suggestions
elif st.session_state.processing_stage == 'review':
    display_suggestion_review(st.session_state.suggestions_data)

    col1, col2 = st.columns(2)

    with col1:
        if st.button("üîÑ Start Over"):
            st.session_state.processing_stage = 'upload'
            st.session_state.suggestions_data = None
            st.session_state.accepted_suggestions = {}
            st.rerun()

    with col2:
        if st.button("‚úÖ Generate Final Document"):
            st.session_state.processing_stage = 'final'
            st.rerun()

# Stage 3: Generate Final Document
elif st.session_state.processing_stage == 'final':
    st.header("üìÑ Generating Final Document")

    with st.spinner("Generating final document with your accepted suggestions..."):
        try:
            # Generate final content with only accepted suggestions
            rewritten_html_content = run_final_processing_with_accepted_suggestions(
                st.session_state.suggestions_data, 
                st.session_state.accepted_suggestions, 
                st.session_state.uploaded_nda_name
            )

            if rewritten_html_content:
                # Generate and save output files (using your original function)
                html_path, docx_path, html_no_rationale_path = generate_and_save_outputs(
                    rewritten_html_content, 
                    st.session_state.uploaded_nda_name
                )

                preprocessed_filename = preprocess_filename(st.session_state.uploaded_nda_name)

                st.success("Processing complete!")

                # Display results (same as your original)
                st.subheader("Results")
                excel_report_path = st.session_state.suggestions_data['reports_filename']
                st.markdown(f"**Reports saved to:** `{excel_report_path}`")

                # Show summary of accepted suggestions
                accepted_count = sum(1 for v in st.session_state.accepted_suggestions.values() if v)
                total_count = len(st.session_state.suggestions_data['dedup_amendments_report'])
                st.info(f"Applied {accepted_count} out of {total_count} suggested changes")

                # Show the HTML result directly in the app (same as your original)
                st.subheader("Rewritten NDA (HTML)")
                st.markdown(rewritten_html_content, unsafe_allow_html=True)

                # Download buttons (same as your original)
                with open(html_path, "r", encoding="utf-8") as f:
                    st.download_button(
                        label="Download Rewritten HTML",
                        data=f.read(),
                        file_name=os.path.basename(html_path),
                        mime="text/html"
                    )

                with open(docx_path, "rb") as f:
                    st.download_button(
                        label="Download Rewritten DOCX",
                        data=f.read(),
                        file_name=os.path.basename(docx_path),
                        mime="application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                    )

                # Navigation options
                col1, col2 = st.columns(2)
                with col1:
                    if st.button("üìù Review Suggestions Again"):
                        st.session_state.processing_stage = 'review'
                        st.rerun()
                with col2:
                    if st.button("üîÑ Start New Document"):
                        st.session_state.processing_stage = 'upload'
                        st.session_state.suggestions_data = None
                        st.session_state.accepted_suggestions = {}
                        st.rerun()

        except Exception as e:
            st.error(f"An error occurred during final processing: {e}")
            if st.button("üîÑ Back to Review"):
                st.session_state.processing_stage = 'review'
                st.rerun()
